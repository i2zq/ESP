-- Enhanced Rainbow ESP Script for Roblox (Performance Optimized)
-- Features: Rainbow Box ESP, Tracers, Health Bars, Distance, Name Display, and Skeleton ESP

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

-- Configuration
local Config = {
    Enabled = false,
    BoxESP = true,
    Tracers = true,
    HealthBar = true,
    Names = true,
    Distance = true,
    Skeleton = true,
    TeamCheck = false,  -- Set to true to ignore teammates
    RainbowSpeed = 1,   -- Speed of rainbow color cycle (lower = slower)
    BoxThickness = 2,
    TracerThickness = 1,
    SkeletonThickness = 1,
    TracerOrigin = "Bottom", -- "Bottom", "Center", or "Mouse"
    MaxDistance = 1000, -- Maximum render distance
    TextSize = 14,
    ToggleKey = Enum.KeyCode.RightShift, -- Key to toggle ESP
    Transparency = 0.8, -- ESP transparency (0-1)
    
    -- Performance Options
    UpdateRate = 0.03,  -- Update ESP every X seconds instead of every frame (lower = more frequent updates)
    MaxPlayersToRender = 10, -- Max number of players to render ESP for at once
    DistancePriority = true, -- Prioritize closer players when limiting
    SkeletonUpdateRate = 0.1, -- Update skeleton less frequently than other elements
    CullDistance = 150,  -- Hide skeleton ESP for players beyond this distance
    DynamicRendering = true -- Automatically adjust settings based on FPS
}

-- Performance tracking
local FPSCounter = {
    Frames = 0,
    LastTime = tick(),
    FPS = 60
}

-- Drawing objects storage
local ESPObjects = {}
local ActivePlayers = {} -- Sorted list of players to render
local LastSkeletonUpdate = 0
local LastESPUpdate = 0

-- Global rainbow color (shared across all ESP elements)
local GlobalRainbowColor = Color3.new(1, 0, 0)
local TracerColor = Color3.new(1, 1, 1) -- Static white color for tracers

-- Function to update global rainbow color
local function updateGlobalRainbow()
    local time = tick() * Config.RainbowSpeed
    GlobalRainbowColor = Color3.fromHSV(time % 1, 1, 1)
end

-- Function to update FPS counter
local function updateFPS()
    FPSCounter.Frames = FPSCounter.Frames + 1
    local currentTime = tick()
    local elapsed = currentTime - FPSCounter.LastTime
    
    if elapsed >= 1 then
        FPSCounter.FPS = FPSCounter.Frames / elapsed
        FPSCounter.Frames = 0
        FPSCounter.LastTime = currentTime
        
        -- Dynamic settings adjustment based on FPS
        if Config.DynamicRendering then
            if FPSCounter.FPS < 30 then
                -- Low FPS adjustments
                Config.SkeletonUpdateRate = 0.3
                Config.CullDistance = 100
                Config.MaxPlayersToRender = 5
            elseif FPSCounter.FPS < 45 then
                -- Medium FPS adjustments
                Config.SkeletonUpdateRate = 0.2
                Config.CullDistance = 125
                Config.MaxPlayersToRender = 8
            else
                -- High FPS - use default settings
                Config.SkeletonUpdateRate = 0.1
                Config.CullDistance = 150
                Config.MaxPlayersToRender = 10
            end
        end
    end
end

-- Function to get skeleton joint positions (optimized)
local function getSkeletonPositions(character)
    if not character then return {} end
    
    -- Define the skeleton connections (joint pairs)
    local connections = {
        -- Torso
        {"Head", "UpperTorso"},
        {"UpperTorso", "LowerTorso"},
        
        -- Left Arm
        {"UpperTorso", "LeftUpperArm"},
        {"LeftUpperArm", "LeftLowerArm"},
        {"LeftLowerArm", "LeftHand"},
        
        -- Right Arm
        {"UpperTorso", "RightUpperArm"},
        {"RightUpperArm", "RightLowerArm"},
        {"RightLowerArm", "RightHand"},
        
        -- Left Leg
        {"LowerTorso", "LeftUpperLeg"},
        {"LeftUpperLeg", "LeftLowerLeg"},
        {"LeftLowerLeg", "LeftFoot"},
        
        -- Right Leg
        {"LowerTorso", "RightUpperLeg"},
        {"RightUpperLeg", "RightLowerLeg"},
        {"RightLowerLeg", "RightFoot"}
    }
    
    -- Alternative connections for R6 rigs (fewer points for better performance)
    local R6Connections = {
        {"Head", "Torso"},
        {"Torso", "Left Arm"},
        {"Torso", "Right Arm"},
        {"Torso", "Left Leg"},
        {"Torso", "Right Leg"}
    }
    
    local positions = {}
    
    -- Check if character uses R15 rig
    if character:FindFirstChild("UpperTorso") then
        -- R15 rig
        for _, connection in ipairs(connections) do
            local part1 = character:FindFirstChild(connection[1])
            local part2 = character:FindFirstChild(connection[2])
            
            if part1 and part2 then
                -- Only calculate viewport positions for the skeleton if they'll be visible
                local pos1 = Camera:WorldToViewportPoint(part1.Position)
                local pos2 = Camera:WorldToViewportPoint(part2.Position)
                
                if pos1.Z > 0 and pos2.Z > 0 then  -- Check if both points are in front of camera
                    table.insert(positions, {
                        From = Vector2.new(pos1.X, pos1.Y),
                        To = Vector2.new(pos2.X, pos2.Y)
                    })
                end
            end
        end
    else
        -- R6 rig
        for _, connection in ipairs(R6Connections) do
            local part1 = character:FindFirstChild(connection[1])
            local part2 = character:FindFirstChild(connection[2])
            
            if part1 and part2 then
                local pos1 = Camera:WorldToViewportPoint(part1.Position)
                local pos2 = Camera:WorldToViewportPoint(part2.Position)
                
                if pos1.Z > 0 and pos2.Z > 0 then
                    table.insert(positions, {
                        From = Vector2.new(pos1.X, pos1.Y),
                        To = Vector2.new(pos2.X, pos2.Y)
                    })
                end
            end
        end
    end
    
    return positions
end

-- Function to check if a player should have ESP
local function shouldShowESP(player)
    if not Config.Enabled then return false end
    if player == LocalPlayer then return false end
    
    local character = player.Character
    if not character then return false end
    
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid or humanoid.Health <= 0 then return false end
    
    if Config.TeamCheck and player.Team == LocalPlayer.Team then return false end
    
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return false end
    
    local distance = (rootPart.Position - Camera.CFrame.Position).Magnitude
    if distance > Config.MaxDistance then return false end
    
    return true, distance -- Return distance as second value for sorting
end

-- Function to create new ESP objects for a player (only when needed)
local function createESPForPlayer(player)
    if ESPObjects[player] then return end
    
    ESPObjects[player] = {
        Box = Drawing.new("Square"),
        BoxOutline = Drawing.new("Square"),
        Tracer = Drawing.new("Line"),
        TracerOutline = Drawing.new("Line"),
        Name = Drawing.new("Text"),
        Distance = Drawing.new("Text"),
        HealthBar = Drawing.new("Square"),
        HealthBarOutline = Drawing.new("Square"),
        HealthBarFill = Drawing.new("Square"),
        Skeleton = {},
        LastSkeletonUpdate = 0 -- Track last skeleton update time for this player
    }
    
    -- Box Setup
    ESPObjects[player].BoxOutline.Thickness = Config.BoxThickness + 2
    ESPObjects[player].BoxOutline.Filled = false
    ESPObjects[player].BoxOutline.Color = Color3.new(0, 0, 0)
    ESPObjects[player].BoxOutline.Transparency = Config.Transparency
    
    ESPObjects[player].Box.Thickness = Config.BoxThickness
    ESPObjects[player].Box.Filled = false
    ESPObjects[player].Box.Transparency = Config.Transparency
    
    -- Tracer Setup
    ESPObjects[player].TracerOutline.Thickness = Config.TracerThickness + 2
    ESPObjects[player].TracerOutline.Color = Color3.new(0, 0, 0)
    ESPObjects[player].TracerOutline.Transparency = Config.Transparency
    
    ESPObjects[player].Tracer.Thickness = Config.TracerThickness
    ESPObjects[player].Tracer.Transparency = Config.Transparency
    ESPObjects[player].Tracer.Color = TracerColor
    
    -- Name Setup
    ESPObjects[player].Name.Size = Config.TextSize
    ESPObjects[player].Name.Center = true
    ESPObjects[player].Name.Outline = true
    ESPObjects[player].Name.Color = Color3.new(1, 1, 1)
    ESPObjects[player].Name.Transparency = Config.Transparency
    
    -- Distance Setup
    ESPObjects[player].Distance.Size = Config.TextSize
    ESPObjects[player].Distance.Center = true
    ESPObjects[player].Distance.Outline = true
    ESPObjects[player].Distance.Color = Color3.new(1, 1, 1)
    ESPObjects[player].Distance.Transparency = Config.Transparency
    
    -- Health Bar Setup
    ESPObjects[player].HealthBarOutline.Thickness = 1
    ESPObjects[player].HealthBarOutline.Filled = false
    ESPObjects[player].HealthBarOutline.Color = Color3.new(0, 0, 0)
    ESPObjects[player].HealthBarOutline.Transparency = Config.Transparency
    
    ESPObjects[player].HealthBar.Thickness = 1
    ESPObjects[player].HealthBar.Filled = false
    ESPObjects[player].HealthBar.Color = Color3.new(0, 0, 0)
    ESPObjects[player].HealthBar.Transparency = Config.Transparency
    
    ESPObjects[player].HealthBarFill.Thickness = 1
    ESPObjects[player].HealthBarFill.Filled = true
    ESPObjects[player].HealthBarFill.Transparency = Config.Transparency
end

-- Function to create or update skeleton drawings (optimized to create lines only when needed)
local function updateSkeletonForPlayer(player, skeletonPositions)
    local playerObjects = ESPObjects[player]
    if not playerObjects then return end
    
    -- Clear old skeleton lines if count changed
    if #playerObjects.Skeleton ~= #skeletonPositions * 2 then  -- Each connection needs a line and outline
        for _, line in ipairs(playerObjects.Skeleton) do
            line:Remove()
        end
        playerObjects.Skeleton = {}
        
        -- Create new lines
        for i = 1, #skeletonPositions do
            -- Line outline
            local outline = Drawing.new("Line")
            outline.Thickness = Config.SkeletonThickness + 2
            outline.Color = Color3.new(0, 0, 0)
            outline.Transparency = Config.Transparency
            
            -- Main line
            local line = Drawing.new("Line")
            line.Thickness = Config.SkeletonThickness
            line.Transparency = Config.Transparency
            
            table.insert(playerObjects.Skeleton, outline)
            table.insert(playerObjects.Skeleton, line)
        end
    end
    
    -- Update skeleton line positions
    for i, connection in ipairs(skeletonPositions) do
        local outlineIndex = (i - 1) * 2 + 1
        local lineIndex = outlineIndex + 1
        
        -- Update only if we have these lines
        if playerObjects.Skeleton[outlineIndex] and playerObjects.Skeleton[lineIndex] then
            playerObjects.Skeleton[outlineIndex].From = connection.From
            playerObjects.Skeleton[outlineIndex].To = connection.To
            playerObjects.Skeleton[outlineIndex].Visible = Config.Enabled and Config.Skeleton
            
            playerObjects.Skeleton[lineIndex].From = connection.From
            playerObjects.Skeleton[lineIndex].To = connection.To
            playerObjects.Skeleton[lineIndex].Color = GlobalRainbowColor
            playerObjects.Skeleton[lineIndex].Visible = Config.Enabled and Config.Skeleton
        end
    end
    
    playerObjects.LastSkeletonUpdate = tick()
end

-- Function to remove ESP objects for a player
local function removeESPForPlayer(player)
    if not ESPObjects[player] then return end
    
    for key, object in pairs(ESPObjects[player]) do
        if key == "Skeleton" then
            for _, line in ipairs(object) do
                line:Remove()
            end
        elseif typeof(object) == "table" and object.Remove then
            object:Remove()
        end
    end
    
    ESPObjects[player] = nil
end

-- Function to get tracer origin position
local function getTracerOrigin()
    if Config.TracerOrigin == "Center" then
        return Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    elseif Config.TracerOrigin == "Bottom" then
        return Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y)
    elseif Config.TracerOrigin == "Mouse" then
        return UserInputService:GetMouseLocation()
    end
end

-- Function to update player priority list (called less frequently)
local function updatePlayerPriority()
    ActivePlayers = {}
    
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            local shouldShow, distance = shouldShowESP(player)
            if shouldShow then
                table.insert(ActivePlayers, {Player = player, Distance = distance})
            end
        end
    end
    
    -- Sort players by distance if needed
    if Config.DistancePriority then
        table.sort(ActivePlayers, function(a, b)
            return a.Distance < b.Distance
        end)
    end
    
    -- Limit to max players
    while #ActivePlayers > Config.MaxPlayersToRender do
        table.remove(ActivePlayers)
    end
    
    -- Create ESP objects for active players if they don't exist
    for _, playerData in ipairs(ActivePlayers) do
        createESPForPlayer(playerData.Player)
    end
end

-- Hide all ESP objects for a player
local function hidePlayerESP(player)
    local objects = ESPObjects[player]
    if not objects then return end
    
    for key, object in pairs(objects) do
        if key == "Skeleton" then
            for _, line in ipairs(object) do
                line.Visible = false
            end
        elseif typeof(object) ~= "number" and object.Visible then
            object.Visible = false
        end
    end
end

-- Update ESP function (optimized)
local function updateESP()
    -- Update FPS counter
    updateFPS()
    
    -- Check if we should update player priority list
    local currentTime = tick()
    
    -- Only update active players list every 0.5 seconds
    if currentTime - LastESPUpdate >= 0.5 then
        updatePlayerPriority()
        LastESPUpdate = currentTime
    end
    
    -- Update global rainbow color (this is cheap)
    updateGlobalRainbow()
    
    -- Process only active players
    for _, playerData in ipairs(ActivePlayers) do
        local player = playerData.Player
        local objects = ESPObjects[player]
        
        if not objects then
            continue
        end
        
        local character = player.Character
        if not character then
            hidePlayerESP(player)
            continue
        end
        
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        
        if not rootPart or not humanoid or humanoid.Health <= 0 then
            hidePlayerESP(player)
            continue
        end
        
        -- Get 3D positions for ESP calculations
        local rootPos = rootPart.Position
        local rootPos2D, rootOnScreen = Camera:WorldToViewportPoint(rootPos)
        local distance = (rootPos - Camera.CFrame.Position).Magnitude
        
        -- If player is off screen or too far, hide ESP
        if not rootOnScreen or distance > Config.MaxDistance then
            hidePlayerESP(player)
            continue
        end
        
        -- Get character size for accurate box (only calculate once per frame)
        local size = (character:GetExtentsSize() * 1.1) -- Slightly bigger than character
        
        local height = math.abs(Camera:WorldToViewportPoint(rootPos + Vector3.new(0, size.Y/2, 0)).Y - Camera:WorldToViewportPoint(rootPos - Vector3.new(0, size.Y/2, 0)).Y)
        local width = height * 0.6 -- Adjust for typical character proportions
        
        -- Calculate distance text
        local distanceText = math.floor(distance) .. "m"
        
        -- Draw box ESP
        objects.Box.Visible = Config.Enabled and Config.BoxESP
        objects.BoxOutline.Visible = Config.Enabled and Config.BoxESP
        
        if Config.Enabled and Config.BoxESP then
            objects.Box.Size = Vector2.new(width, height)
            objects.Box.Position = Vector2.new(rootPos2D.X - width/2, rootPos2D.Y - height/2)
            objects.Box.Color = GlobalRainbowColor
            
            objects.BoxOutline.Size = objects.Box.Size
            objects.BoxOutline.Position = objects.Box.Position
        end
        
        -- Draw tracers
        objects.Tracer.Visible = Config.Enabled and Config.Tracers
        objects.TracerOutline.Visible = Config.Enabled and Config.Tracers
        
        if Config.Enabled and Config.Tracers then
            local tracerOrigin = getTracerOrigin()
            local tracerEnd = Vector2.new(rootPos2D.X, rootPos2D.Y)
            
            objects.Tracer.From = tracerOrigin
            objects.Tracer.To = tracerEnd
            
            objects.TracerOutline.From = tracerOrigin
            objects.TracerOutline.To = tracerEnd
        end
        
        -- Draw name
        objects.Name.Visible = Config.Enabled and Config.Names
        
        if Config.Enabled and Config.Names then
            objects.Name.Text = player.Name
            objects.Name.Position = Vector2.new(rootPos2D.X, rootPos2D.Y - height/2 - 15)
            objects.Name.Color = GlobalRainbowColor
        end
        
        -- Draw distance
        objects.Distance.Visible = Config.Enabled and Config.Distance
        
        if Config.Enabled and Config.Distance then
            objects.Distance.Text = distanceText
            objects.Distance.Position = Vector2.new(rootPos2D.X, rootPos2D.Y + height/2 + 5)
            objects.Distance.Color = GlobalRainbowColor
        end
        
        -- Draw health bar
        objects.HealthBar.Visible = Config.Enabled and Config.HealthBar
        objects.HealthBarOutline.Visible = Config.Enabled and Config.HealthBar
        objects.HealthBarFill.Visible = Config.Enabled and Config.HealthBar
        
        if Config.Enabled and Config.HealthBar and humanoid then
            local healthPercent = humanoid.Health / humanoid.MaxHealth
            local barHeight = height
            local barWidth = 5
            
            objects.HealthBarOutline.Size = Vector2.new(barWidth, barHeight + 2)
            objects.HealthBarOutline.Position = Vector2.new(rootPos2D.X - width/2 - 7, rootPos2D.Y - height/2 - 1)
            
            objects.HealthBar.Size = Vector2.new(barWidth, barHeight)
            objects.HealthBar.Position = Vector2.new(rootPos2D.X - width/2 - 7, rootPos2D.Y - height/2)
            
            objects.HealthBarFill.Size = Vector2.new(barWidth, barHeight * healthPercent)
            objects.HealthBarFill.Position = Vector2.new(rootPos2D.X - width/2 - 7, rootPos2D.Y - height/2 + barHeight * (1 - healthPercent))
            
            -- Health bar color based on health percentage
            if healthPercent > 0.75 then
                objects.HealthBarFill.Color = Color3.new(0, 1, 0) -- Green
            elseif healthPercent > 0.25 then
                objects.HealthBarFill.Color = Color3.new(1, 1, 0) -- Yellow
            else
                objects.HealthBarFill.Color = Color3.new(1, 0, 0) -- Red
            end
        end
        
        -- Draw skeleton (only update at a lower rate and for close players)
        if Config.Enabled and Config.Skeleton and distance < Config.CullDistance then
            -- Only update skeleton every SkeletonUpdateRate seconds to improve performance
            if currentTime - (objects.LastSkeletonUpdate or 0) >= Config.SkeletonUpdateRate then
                local skeletonPositions = getSkeletonPositions(character)
                updateSkeletonForPlayer(player, skeletonPositions)
            end
        else
            -- Hide skeleton if disabled or too far
            for _, line in ipairs(objects.Skeleton) do
                line.Visible = false
            end
        end
    end
end

-- This function handles ESP updates at a controlled rate
local function throttledESPUpdate()
    -- This runs at a fixed interval instead of every frame
    updateESP()
end

-- Setup player connections
local function onPlayerAdded(player)
    -- Don't immediately create ESP for every player, let the priority system handle it
    if player ~= LocalPlayer then
        -- Check if this player should be active
        updatePlayerPriority()
    end
end

local function onPlayerRemoving(player)
    removeESPForPlayer(player)
    
    -- Update priority list when a player leaves
    updatePlayerPriority()
end

-- Initialize ESP Update Loop
local ESPUpdateLoop = nil

-- Function to start ESP
local function startESP()
    if ESPUpdateLoop then return end
    
    -- Initialize active players
    updatePlayerPriority()
    
    -- Connect events
    Players.PlayerAdded:Connect(onPlayerAdded)
    Players.PlayerRemoving:Connect(onPlayerRemoving)
    
    -- Start update loop using throttled updates instead of per-frame
    ESPUpdateLoop = RunService.Heartbeat:Connect(function()
        local currentTime = tick()
        if currentTime - LastESPUpdate >= Config.UpdateRate then
            throttledESPUpdate()
            LastESPUpdate = currentTime
        end
    end)
end

-- Function to stop ESP (clean up)
local function stopESP()
    if not ESPUpdateLoop then return end
    
    ESPUpdateLoop:Disconnect()
    ESPUpdateLoop = nil
    
    -- Clean up all ESP objects
    for player, _ in pairs(ESPObjects) do
        removeESPForPlayer(player)
    end
end

-- Toggle with keybind
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if not gameProcessed and input.KeyCode == Config.ToggleKey then
        Config.Enabled = not Config.Enabled
        
        -- Notification
        game:GetService("StarterGui"):SetCore("SendNotification", {
            Title = "Rainbow ESP",
            Text = Config.Enabled and "Enabled" or "Disabled",
            Duration = 2
        })
    end
end)

-- Initialize ESP system
startESP()

-- For UI Integration
-- Add this to your UI script:
----------------------------------------------------------------
-- ESP Toggle and Performance Settings
----------------------------------------------------------------
--[[
local ESPToggle = Tabs.Main:AddToggle("ESP", {
    Title = "ESP",
    Default = false,
    Callback = function(Value)
        Config.Enabled = Value
    end
})

local ESPDistance = Tabs.Settings:AddSlider("ESPDistance", {
    Title = "Max Distance",
    Min = 100,
    Max = 2000,
    Default = 1000,
    Callback = function(Value)
        Config.MaxDistance = Value
    end
})

local MaxPlayersSlider = Tabs.Settings:AddSlider("MaxPlayers", {
    Title = "Max Players to Render",
    Min = 3,
    Max = 20,
    Default = 10,
    Callback = function(Value)
        Config.MaxPlayersToRender = Value
    end
})
]]--

return {
    SetEnabled = function(value)
        Config.Enabled = value
    end,
    GetEnabled = function()
        return Config.Enabled
    end,
    SetBoxESP = function(value)
        Config.BoxESP = value
    end,
    SetTracers = function(value)
        Config.Tracers = value
    end,
    SetHealthBar = function(value)
        Config.HealthBar = value
    end,
    SetNames = function(value)
        Config.Names = value
    end,
    SetDistance = function(value)
        Config.Distance = value
    end,
    SetSkeleton = function(value)
        Config.Skeleton = value
    end,
    SetRainbowSpeed = function(value)
        Config.RainbowSpeed = value
    end,
    SetMaxDistance = function(value)
        Config.MaxDistance = value
    end,
    SetMaxPlayersToRender = function(value)
        Config.MaxPlayersToRender = value
    end,
    SetUpdateRate = function(value)
        Config.UpdateRate = value
    end,
    ToggleDynamicRendering = function(value)
        Config.DynamicRendering = value
    end,
    CleanupESP = stopESP
}
